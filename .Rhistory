{
simlist[[count]] <- ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
balance
?balance
bb <- ape::balance(phy);
colless <- function(phy){
bb <- ape::balance(phy)
ss <- sum(abs(bb[,1] - bb[,2]))
n <- length(phy$tip.label)
return((2 / ((n-1)*(n-2))) * ss)
}
get.node.age <- function (phy) {
root.node <- length(phy$tip.label)+1
seq.nodes <- phy$edge
dists <- phy$edge.length
res <- numeric(max(phy$edge))
for (i in seq_len(nrow(seq.nodes))) {
res[seq.nodes[i, 2]] <- res[seq.nodes[i,1]] + dists[i]
}
ages <- abs(round(res,2)-round(max(res),2))
return(ages)
}
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
colless <- function(phy){
bb <- ape::balance(phy)
ss <- sum(abs(bb[,1] - bb[,2]))
n <- length(phy$tip.label)
return((2 / ((n-1)*(n-2))) * ss)
}
get.node.age <- function (phy) {
root.node <- length(phy$tip.label)+1
seq.nodes <- phy$edge
dists <- phy$edge.length
res <- numeric(max(phy$edge))
for (i in seq_len(nrow(seq.nodes))) {
res[seq.nodes[i, 2]] <- res[seq.nodes[i,1]] + dists[i]
}
ages <- abs(round(res,2)-round(max(res),2))
return(ages)
}
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
trees <- simple_sim()
trees[[1]]
trees[[1]][``]
trees[[1]][1]
plot(trees[[1]][1])
plot(trees[[1]][[1]])
plot(trees[[1]][[2]])
plot(trees[[1]][[4]])
plot(trees[[1]][[5]])
plot(trees[[1]][[6]])
plot(trees[[1]][[7]])
plot(trees[[1]][[8]])
plot(trees[[1]][[9]])
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(simlist))
}
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(simlist)
}
trees <- simple_sim()
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(max.param = max.param, turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
max.param = 8
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(max.param = max.param, turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
?MiSSEGreedy
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, aic = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
trees
MiSSEGreedy_fullrun(trees[[1]])
quick_test <- MiSSEGreedy_fullrun(trees[[1]])
run_1
trees
phy = trees[[1]]
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
combo
misse_run
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, aic = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
?MarginReconMiSSE
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = suppressWarnings(hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F)) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
quick_test <- MiSSEGreedy_fullrun(trees[[1]])
quick_test
quick_test
tip_rates = hisse::GetModelAveRates(quick_test[[1]][[2]], type = "tips")
quick_test[[1]]
quick_test[[1]][[2]]
tip_rates = hisse::GetModelAveRates(quick_test[[1]], type = "tips")
tip_rates = hisse::GetModelAveRates(quick_test[[2]], type = "tips")
tip_rates = hisse::GetModelAveRates(quick_test[[2]][[2]], type = "tips")
tip_rates
library(hisse)
?MarginReconHiSSE
install.packages(remotes)
library("remotes")
remotes::install_github("LimaRAF/plantR")
spp <- c("Casearia sylvestris", "Euterpe edulis",
"Trema micrantha")
library("plantR")
occs_splink <- rspeciesLink(species = spp, Scope = "plants",
basisOfRecord = "PreservedSpecimen", Synonyms = "flora2020")
occs_gbif <- rgbif2(species = spp,
basisOfRecord = "PRESERVED_SPECIMEN",
remove_na = FALSE, n.records = 500000)
occs_splink
occs_gbif
colnames(occs_gbif)
nrow(occs_splink)
nrow(occs_gbif)
occs <- formatDwc(splink_data = occs_splink, gbif_data = occs_gbif, drop = TRUE)
dim(occs)
occs
occs$recordedBy.new <- prepName(occs$recordedBy, output = "first",
sep.out = "; ")
occs$recordedBy.aux <- prepName(occs$recordedBy, output ="aux", sep.out = "; ")
View(recordedBy.aux)
View(occs)
occs[,c("recordedBy","recordedBy.new","recordedBy.aux")]
View(occs[,c("recordedBy","recordedBy.new","recordedBy.aux")])
library(RPANDA)
data("Caprimulgidae_ClaDS2")
plot_ClaDS_chains(Caprimulgidae_ClaDS2$sampler)
# extract the Maxima A Posteriori for each parameter
maps = getMAPS_ClaDS(Caprimulgidae_ClaDS2$sampler, thin = 1)
print(paste0("sigma = ", maps[1], " ; alpha = ", maps[2], " ; epsilon = ", maps[3], " ; l_0 = ", maps[4] ))
# plot the infered branch specific speciation rates
plot_ClaDS_phylo(Caprimulgidae_ClaDS2$tree, maps[-(1:4)])
# rm(list=ls())
setwd("~/Desktop/WCVP_special_issue/Patricia_Climbers/climbers")
library(maptools)
library(data.table)
data("wrld_simpl")
source("00_utility_functions.R")
source("/Users/thaisvasconcelos/Desktop/WCVP_special_issue/WCVPtools/WCVPtools_functions.R")
climber_points <- as.data.frame(fread("gbif_climbers/climbers_cleaned_points.csv"))
climber_mech <- read.csv("Data/climber_database.csv")
colnames(climber_mech) <- c("family","genus","species","CM","taxized_names")
merged_table <- merge(climber_mech, climber_points, by.x = "taxized_names", by.y = "scientificName")
# Directory to save preliminary datasets:
climate_data.dir <- "./climate_data"
# Directory where climate layers are:
climate_layers.dir <- "./climate_layers"
# 1. Thinning occurence data first
thinned_points <- Thinning(merged_table, species="taxized_names", lat = "decimalLatitude", lon="decimalLongitude", n = 3)
thinned_points <- read.csv(paste0(climate_data.dir, "/climbers_thinned_points.csv"))
allpoints<-read.csv(paste0(climate_data.dir, "/climbers_allpoints.csv"))
summstats <- GetClimateSummStats_custom(allpoints, type="raw")
write.csv(summstats, file=paste0(climate_data.dir, "/climbers_summstats_raw.csv"), row.names=F)
summstats <- GetClimateSummStats_custom(allpoints, type="transformed")
write.csv(summstats, file=paste0(climate_data.dir, "/climbers_summstats.csv"), row.names=F)
summstats <- GetClimateSummStats_custom(allpoints, type="transformed")
write.csv(summstats, file=paste0(climate_data.dir, "/climbers_summstats.csv"), row.names=F)
# Different ways in which we can test this:
# (1) Phyloanovas
# Higher AI will represent higher potential for vegetation growth (i.e. closed canopy environments)
summstats <- read.csv(paste0(climate_data.dir, "/climbers_summstats.csv"))
ai_table <- summstats[,c("species","mean_aridity")]
ai_table$mean_aridity <- as.numeric(ai_table$mean_aridity)
merged_table <- merge(climber_mech, ai_table, by.x="taxized_names", by.y="species")
boxplot(exp(merged_table$mean_aridity) ~ merged_table$CM)
# Load tree for PCMs
library(ape)
library(phytools)
tree <- readRDS("Data/taxized_GBMB.Rdata")
tree$tip.label
tree$tip.label <- unname(tree$tip.label)
subset_merged_table <- subset(merged_table, merged_table$taxized_names%in%tree$tip.label)
subset_merged_table <- subset(subset_merged_table, !duplicated(subset_merged_table$taxized_names))
pruned_tree <- keep.tip(tree, intersect(subset_merged_table$taxized_names, tree$tip.label))
pruned_tree$tip.label <- paste0(unlist(lapply(strsplit(pruned_tree$tip.label, " "), "[[", 1)), " ", unlist(lapply(strsplit(pruned_tree$tip.label, " "), "[[", 2)))
subset_merged_table$taxized_names <- paste0(unlist(lapply(strsplit(subset_merged_table$taxized_names, " "), "[[", 1)), " ", unlist(lapply(strsplit(subset_merged_table$taxized_names, " "), "[[", 2)))
# Figure
boxplot(exp(subset_merged_table$mean_aridity) ~ subset_merged_table$CM)
aridity <- subset_merged_table$mean_aridity
mechanisms <- subset_merged_table$CM
names(aridity) <- names(mechanisms) <- subset_merged_table$taxized_names
class(mechanisms)
mechanisms[which(mechanisms==1)] <- "a"
mechanisms[which(mechanisms==2)] <- "b"
mechanisms[which(mechanisms==3)] <- "c"
mechanisms[which(mechanisms==4)] <- "d"
mechanisms[which(mechanisms==5)] <- "e"
mechanisms[which(mechanisms==6)] <- "f"
mechanisms[which(mechanisms==7)] <- "g"
mechanisms[which(mechanisms==8)] <- "h"
phyanova <- phylANOVA(pruned_tree, mechanisms, aridity)
phyanova
aridity
phyanova <- phylANOVA(pruned_tree, mechanisms, exp(aridity))
phyanova
length(aridity)
# rm(list=ls())
setwd("~/Desktop/WCVP_special_issue/Patricia_Climbers/climbers")
source("00_utility_functions.R")
#-----------------------------
# If local
source("/Users/thaisvasconcelos/Desktop/WCVP_special_issue/WCVPtools/WCVPtools_functions.R")
dist_sample <- read.table("../../wcvp_names_and_distribution_special_edition_2022/wcvp_distribution.txt", sep="|", header=TRUE, quote = "", fill=TRUE, encoding = "UTF-8")
names_sample <- read.table("../../wcvp_names_and_distribution_special_edition_2022/wcvp_names.txt", sep="|", header=TRUE, quote = "", fill=TRUE, encoding = "UTF-8")
#-----------------------------
# Merge them in one big table
all_vars <- merge(dist_sample, names_sample, by="plant_name_id")
# reference table for taxized names
#-----------------------------
# If local
reference_table <- list.files("/Users/thaisvasconcelos/Desktop/WCVP_special_issue/WCVPtools/taxized_reference_tables", full.names = T)
reference_table <- do.call(rbind, lapply(reference_table, read.csv))
reference_table$gbif_name <- fix.names.taxize(reference_table$gbif_name)
# Reading gbif file
gbif_data <- fread("gbif_climbers/0306501-210914110416597.csv") # load the table you downloaded from GBIF
# Looking at the WCVP table and TDWG to clean GBIF points
#-----------------------------
# If local
path="/Users/thaisvasconcelos/Desktop/WCVP_special_issue/WCVPtools/wgsrpd-master/level3/level3.shp"
twgd_data <- suppressWarnings(maptools::readShapeSpatial(path))
#------ Cleaning steps:
cleaned_points <- gbif_data
# WCVP filtering
subset_reference_table <- subset(reference_table, reference_table$gbif_name %in% unique(cleaned_points$scientificName))
subset_all_vars <- subset(all_vars, all_vars$taxon_name %in% subset_reference_table$wcvp_name)
cleaned_points <- FilterWCVP_genus(cleaned_points, subset_all_vars, twgd_data)
# 0 points removed
unique(cleaned_points$species)
# 0 points removed
length(unique(cleaned_points$species))
