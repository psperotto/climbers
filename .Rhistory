lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
balance
?balance
bb <- ape::balance(phy);
colless <- function(phy){
bb <- ape::balance(phy)
ss <- sum(abs(bb[,1] - bb[,2]))
n <- length(phy$tip.label)
return((2 / ((n-1)*(n-2))) * ss)
}
get.node.age <- function (phy) {
root.node <- length(phy$tip.label)+1
seq.nodes <- phy$edge
dists <- phy$edge.length
res <- numeric(max(phy$edge))
for (i in seq_len(nrow(seq.nodes))) {
res[seq.nodes[i, 2]] <- res[seq.nodes[i,1]] + dists[i]
}
ages <- abs(round(res,2)-round(max(res),2))
return(ages)
}
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
colless <- function(phy){
bb <- ape::balance(phy)
ss <- sum(abs(bb[,1] - bb[,2]))
n <- length(phy$tip.label)
return((2 / ((n-1)*(n-2))) * ss)
}
get.node.age <- function (phy) {
root.node <- length(phy$tip.label)+1
seq.nodes <- phy$edge
dists <- phy$edge.length
res <- numeric(max(phy$edge))
for (i in seq_len(nrow(seq.nodes))) {
res[seq.nodes[i, 2]] <- res[seq.nodes[i,1]] + dists[i]
}
ages <- abs(round(res,2)-round(max(res),2))
return(ages)
}
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
trees <- simple_sim()
trees[[1]]
trees[[1]][``]
trees[[1]][1]
plot(trees[[1]][1])
plot(trees[[1]][[1]])
plot(trees[[1]][[2]])
plot(trees[[1]][[4]])
plot(trees[[1]][[5]])
plot(trees[[1]][[6]])
plot(trees[[1]][[7]])
plot(trees[[1]][[8]])
plot(trees[[1]][[9]])
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(simlist))
}
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(simlist)
}
trees <- simple_sim()
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(max.param = max.param, turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
max.param = 8
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(max.param = max.param, turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
?MiSSEGreedy
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, aic = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
trees
MiSSEGreedy_fullrun(trees[[1]])
quick_test <- MiSSEGreedy_fullrun(trees[[1]])
run_1
trees
phy = trees[[1]]
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
combo
misse_run
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, aic = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
?MarginReconMiSSE
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = suppressWarnings(hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F)) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
quick_test <- MiSSEGreedy_fullrun(trees[[1]])
quick_test
quick_test
tip_rates = hisse::GetModelAveRates(quick_test[[1]][[2]], type = "tips")
quick_test[[1]]
quick_test[[1]][[2]]
tip_rates = hisse::GetModelAveRates(quick_test[[1]], type = "tips")
tip_rates = hisse::GetModelAveRates(quick_test[[2]], type = "tips")
tip_rates = hisse::GetModelAveRates(quick_test[[2]][[2]], type = "tips")
tip_rates
library(hisse)
?MarginReconHiSSE
install.packages(remotes)
library("remotes")
remotes::install_github("LimaRAF/plantR")
spp <- c("Casearia sylvestris", "Euterpe edulis",
"Trema micrantha")
library("plantR")
occs_splink <- rspeciesLink(species = spp, Scope = "plants",
basisOfRecord = "PreservedSpecimen", Synonyms = "flora2020")
occs_gbif <- rgbif2(species = spp,
basisOfRecord = "PRESERVED_SPECIMEN",
remove_na = FALSE, n.records = 500000)
occs_splink
occs_gbif
colnames(occs_gbif)
nrow(occs_splink)
nrow(occs_gbif)
occs <- formatDwc(splink_data = occs_splink, gbif_data = occs_gbif, drop = TRUE)
dim(occs)
occs
occs$recordedBy.new <- prepName(occs$recordedBy, output = "first",
sep.out = "; ")
occs$recordedBy.aux <- prepName(occs$recordedBy, output ="aux", sep.out = "; ")
View(recordedBy.aux)
View(occs)
occs[,c("recordedBy","recordedBy.new","recordedBy.aux")]
View(occs[,c("recordedBy","recordedBy.new","recordedBy.aux")])
setwd("~/Desktop/Colabs/Patricia_Climbers/climbers")
# Load all Neotropical stuff
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
library(data.table)
# Load all Neotropical stuff
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
# Load all Neotropical stuff
gbif_dir <- paste0(getwd(), "/full_gbif_quest")
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
full_list <- full_list[,-1]
# Now load table climbers
climbers <- read.csv("Data/climber_database.csv", stringsAsFactors = F)
source("neotropical_climbers_functions.R")
climbers
taxized_climbers <- gbif.taxize(climbers)
climbers
taxized_climbers <- gbif.taxize(climbers$Species)
q
climbers <- read.csv("Data/climber_database.csv", stringsAsFactors = F)
climbers
is.duplicated(climbers$taxized_names)
duplicated(climbers$taxized_names)
which(duplicated(climbers$taxized_names))
length(which(duplicated(climbers$taxized_names)))
grep("UNMATCHED", climbers$taxized_names)
grep("UN", climbers$taxized_names)
climbers$taxized_names
which(duplicated(climbers$taxized_names))
View(climbers)
climbers$taxized_names[which(duplicated(climbers$taxized_names))]
#---------------------
# Making master table
# Load all Neotropical stuff
gbif_dir <- paste0(getwd(), "/full_gbif_quest")
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
full_list <- full_list[,-1]
length(unique(full_list$species))
full_list
full_list$species %in% climbers$taxized_names
unique(full_list$species) %in% climbers$taxized_names
length(unique(full_list$species) %in% climbers$taxized_names)
length(which(unique(full_list$species) %in% climbers$taxized_names))
climbers$taxized_names[which(unique(full_list$species) %in% climbers$taxized_names)]
View(climbers)
is.na(climbers$taxized_names)
which(is.na(climbers$taxized_names))
all_neotropical_species <- unique(full_list$species)
all_neotropical_species
which(is.na(all_neotropical_species))
intersect(all_neotropical_species, climbers$taxized_names)
climbers_w_points <- intersect(all_neotropical_species, climbers$taxized_names)
climbers_w_points
climbers_w_points
i=1
full_list[full_list$species==climbers_w_points[i],]
climbers_w_points[i]
full_list$species==climbers_w_points[i]
which(full_list[full_list$species==climbers_w_points[i],])
full_list[full_list$species==climbers_w_points[i],]
which(full_list$species==climbers_w_points[i])
full_list$mechanism <- NA
one_climber <- climbers_w_points[i]
one_climber
climbers_w_points
which(climbers$taxized_names==one_climber)
climbers$CM[which(climbers$taxized_names==one_climber)]
paste0("Mechanism_", climbers$CM[which(climbers$taxized_names==one_climber)])
mechanism <- paste0("Mechanism_", climbers$CM[which(climbers$taxized_names==one_climber)])
which(full_list$species==climbers_w_points[i]
)
for(i in 1:length(climbers_w_points)) {
one_climber <- climbers_w_points[i]
mechanism <- paste0("Mechanism_", climbers$CM[which(climbers$taxized_names==one_climber)])
full_list$mechanism[which(full_list$species==climbers_w_points[i])] <- mechanism
print(i)
}
is.na(full_list$mechanism)
full_list$mechanism[which(is.na(full_list$mechanism))] <- "not_a_climber"
head(full_list)
write.csv(full_list, file="full_gbif_quest/master_table.csv", row.names = NULL)
write.csv(full_list, file="full_gbif_quest/master_table.csv", row.names = F)
plot(full_list$mechanism)
dev.off()
unique(full_list$mechanism)
full_list$mechanism
table(full_list$mechanism)
