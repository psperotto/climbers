# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(list(simlist, parslist))
}
simple_sim()
trees <- simple_sim()
trees[[1]]
trees[[1]][``]
trees[[1]][1]
plot(trees[[1]][1])
plot(trees[[1]][[1]])
plot(trees[[1]][[2]])
plot(trees[[1]][[4]])
plot(trees[[1]][[5]])
plot(trees[[1]][[6]])
plot(trees[[1]][[7]])
plot(trees[[1]][[8]])
plot(trees[[1]][[9]])
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(simlist))
}
simple_sim <- function (nsim=100, max.taxa=50, x0=3, include.extinct=FALSE, min.state=0.1) {
simlist <- list()
parslist <- list()
count <- 1
while (count != nsim) {
# some good pars to get umbalanced trees
turnover1 <- runif(1, min=0, max=2)
eps1 <- runif(1, min=0.2, max=0.5)
turnover2 <- runif(1, min=0, max=1)
eps2 <- runif(1, min=0, max=0.3)
turnover3 <- runif(1, min=3, max=6)
eps3 <- runif(1, min=0.6, max=0.9)
qs <- c(rep(0.01, 4), 0.1, 0.05)
# setting lambda and mu parameters from turnover and eps
lambda1 = turnover1/ (eps1+1)
mu1 = eps1 * lambda1
lambda2 = turnover2/ (eps2+1)
mu2 = eps2 * lambda2
lambda3 = turnover3/ (eps3+1)
mu3 = eps3 * lambda3
# passing parameters to diversitree function
parnames <- diversitree:::default.argnames.musse(k=3)
pars <- c(lambda1, lambda2, lambda3,mu1, mu2, mu3, qs)
names(pars) <- parnames
# simulating tree
phy <- diversitree::tree.musse(pars, max.taxa=max.taxa, x0=x0, include.extinct=include.extinct)
# filtering results based on a series of conditions
if(!is.null(phy) && # Non-null
length(diversitree::prune(phy)$tip.label) == max.taxa && # max.taxa surviving to the present
min(table(diversitree::prune(phy)$tip.state)) >= max.taxa*min.state && # Each state with at least min.state representation
colless(phy) > 0.05 && # Colless threshold
"3" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"1" %in% names(table(diversitree::prune(phy)$tip.state)) &&
"2" %in% names(table(diversitree::prune(phy)$tip.state)) &&
max(get.node.age(phy)) > 5 # at least 5 mya
)
{
simlist[[count]] <- ape::ladderize(phy)
parslist[[count]] <- pars
count <- count + 1
}
}
return(simlist)
}
trees <- simple_sim()
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(max.param = max.param, turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
max.param = 8
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(max.param = max.param, turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2,
eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
combo
?MiSSEGreedy
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, aic = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
trees
MiSSEGreedy_fullrun(trees[[1]])
quick_test <- MiSSEGreedy_fullrun(trees[[1]])
run_1
trees
phy = trees[[1]]
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
combo
misse_run
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, aic = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
?MarginReconMiSSE
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
MiSSEGreedy_fullrun <- function(phy) {
# creating a matrix of possible combinations of parameter:
combo = hisse::generateMiSSEGreedyCombinations(turnover.tries = 1:2, eps.tries = 1:2, fixed.eps.tries=c(0, 0.9, NA), vary.both=T)
# run MiSSE models:
misse_run = suppressWarnings(hisse::MiSSEGreedy(phy, f=1, possible.combos = combo, root.type="madfitz", stop.deltaAICc=Inf, chunk.size = 4, turnover.upper=20, trans.upper=10, sann=F)) #
model.recons1 <- as.list(1:length(misse_run))
for (model_index in 1:length(misse_run)) {
nturnover <- length(unique(misse_run[[model_index]]$turnover))
neps <- length(unique(misse_run[[model_index]]$eps))
hisse_recon <- hisse::MarginReconMiSSE(phy = misse_run[[model_index]]$phy, f = 1, hidden.states = nturnover,
pars = misse_run[[model_index]]$solution, AIC = misse_run[[model_index]]$AIC, root.type = "madfitz")
model.recons1[[model_index]] <- hisse_recon
}
return(list(misse_run, model.recons1))
}
quick_test <- MiSSEGreedy_fullrun(trees[[1]])
quick_test
quick_test
tip_rates = hisse::GetModelAveRates(quick_test[[1]][[2]], type = "tips")
quick_test[[1]]
quick_test[[1]][[2]]
tip_rates = hisse::GetModelAveRates(quick_test[[1]], type = "tips")
tip_rates = hisse::GetModelAveRates(quick_test[[2]], type = "tips")
tip_rates = hisse::GetModelAveRates(quick_test[[2]][[2]], type = "tips")
tip_rates
library(hisse)
?MarginReconHiSSE
install.packages(remotes)
library("remotes")
remotes::install_github("LimaRAF/plantR")
spp <- c("Casearia sylvestris", "Euterpe edulis",
"Trema micrantha")
library("plantR")
occs_splink <- rspeciesLink(species = spp, Scope = "plants",
basisOfRecord = "PreservedSpecimen", Synonyms = "flora2020")
occs_gbif <- rgbif2(species = spp,
basisOfRecord = "PRESERVED_SPECIMEN",
remove_na = FALSE, n.records = 500000)
occs_splink
occs_gbif
colnames(occs_gbif)
nrow(occs_splink)
nrow(occs_gbif)
occs <- formatDwc(splink_data = occs_splink, gbif_data = occs_gbif, drop = TRUE)
dim(occs)
occs
occs$recordedBy.new <- prepName(occs$recordedBy, output = "first",
sep.out = "; ")
occs$recordedBy.aux <- prepName(occs$recordedBy, output ="aux", sep.out = "; ")
View(recordedBy.aux)
View(occs)
occs[,c("recordedBy","recordedBy.new","recordedBy.aux")]
View(occs[,c("recordedBy","recordedBy.new","recordedBy.aux")])
setwd("~/Desktop/Colabs/Patricia_Climbers/climbers")
# Load all Neotropical stuff
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
library(data.table)
# Load all Neotropical stuff
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
# Load all Neotropical stuff
gbif_dir <- paste0(getwd(), "/full_gbif_quest")
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
full_list <- full_list[,-1]
# Now load table climbers
climbers <- read.csv("Data/climber_database.csv", stringsAsFactors = F)
source("neotropical_climbers_functions.R")
climbers
taxized_climbers <- gbif.taxize(climbers)
climbers
taxized_climbers <- gbif.taxize(climbers$Species)
q
climbers <- read.csv("Data/climber_database.csv", stringsAsFactors = F)
climbers
is.duplicated(climbers$taxized_names)
duplicated(climbers$taxized_names)
which(duplicated(climbers$taxized_names))
length(which(duplicated(climbers$taxized_names)))
grep("UNMATCHED", climbers$taxized_names)
grep("UN", climbers$taxized_names)
climbers$taxized_names
which(duplicated(climbers$taxized_names))
View(climbers)
climbers$taxized_names[which(duplicated(climbers$taxized_names))]
#---------------------
# Making master table
# Load all Neotropical stuff
gbif_dir <- paste0(getwd(), "/full_gbif_quest")
full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
full_list <- full_list[,-1]
length(unique(full_list$species))
full_list
full_list$species %in% climbers$taxized_names
unique(full_list$species) %in% climbers$taxized_names
length(unique(full_list$species) %in% climbers$taxized_names)
length(which(unique(full_list$species) %in% climbers$taxized_names))
climbers$taxized_names[which(unique(full_list$species) %in% climbers$taxized_names)]
View(climbers)
is.na(climbers$taxized_names)
which(is.na(climbers$taxized_names))
all_neotropical_species <- unique(full_list$species)
all_neotropical_species
which(is.na(all_neotropical_species))
intersect(all_neotropical_species, climbers$taxized_names)
climbers_w_points <- intersect(all_neotropical_species, climbers$taxized_names)
climbers_w_points
climbers_w_points
i=1
full_list[full_list$species==climbers_w_points[i],]
climbers_w_points[i]
full_list$species==climbers_w_points[i]
which(full_list[full_list$species==climbers_w_points[i],])
full_list[full_list$species==climbers_w_points[i],]
which(full_list$species==climbers_w_points[i])
full_list$mechanism <- NA
one_climber <- climbers_w_points[i]
one_climber
climbers_w_points
which(climbers$taxized_names==one_climber)
climbers$CM[which(climbers$taxized_names==one_climber)]
paste0("Mechanism_", climbers$CM[which(climbers$taxized_names==one_climber)])
mechanism <- paste0("Mechanism_", climbers$CM[which(climbers$taxized_names==one_climber)])
which(full_list$species==climbers_w_points[i]
)
for(i in 1:length(climbers_w_points)) {
one_climber <- climbers_w_points[i]
mechanism <- paste0("Mechanism_", climbers$CM[which(climbers$taxized_names==one_climber)])
full_list$mechanism[which(full_list$species==climbers_w_points[i])] <- mechanism
print(i)
}
is.na(full_list$mechanism)
full_list$mechanism[which(is.na(full_list$mechanism))] <- "not_a_climber"
head(full_list)
write.csv(full_list, file="full_gbif_quest/master_table.csv", row.names = NULL)
write.csv(full_list, file="full_gbif_quest/master_table.csv", row.names = F)
plot(full_list$mechanism)
dev.off()
unique(full_list$mechanism)
full_list$mechanism
table(full_list$mechanism)
# PD maps
# Making individual rasters
all_climber_species <- unique(all_climbers$species)
library(data.table)
library(monographaR)
library(tidyverse)
library(raster)
library(CoordinateCleaner)
library(ape)
library(maptools)
data("wrld_simpl")
source("neotropical_climbers_functions.R")
# Load master table
full_list <- fread("full_gbif_quest/master_table.csv")
##############
# Directory for descriptive results
descriptive_dir <- paste0(getwd(), "/1_descriptive")
#full_list <- fread(paste0(gbif_dir, "/neotropics_tracheophyte_filtered_gbif.csv"))
#full_list <- full_list[,-1]
full_map <- run.mapDiversity.neotropics(full_list[,-4], filename="full_neotropical_diversity", dir=descriptive_dir) # function modified from monographaR
all_climbers <- subset(full_list, full_list$mechanism != "not_a_climber")
all_climbers_map <- run.mapDiversity.neotropics(all_climbers[,-4], filename="all_climbers_neotropical_diversity", dir=descriptive_dir)
# PD maps
# Making individual rasters
all_climber_species <- unique(all_climbers$species)
list_of_climber_distribution <- list()
for(i in 1:length(all_climber_species)){
one_species <- all_climber_species[i]
some_points <- subset(all_climbers[,1:3], all_climbers$species==one_species)
list_of_climber_distribution[[i]] <- monographaR::mapDiversity(as.data.frame(some_points), plot = F, export = F)
print(i)
}
# Loading tree
list_of_climber_distribution <- readRDS("Data/list_of_climber_distribution.Rdata")
sb_tree <- readRDS("Data/taxized_GBMB.Rdata")
tips_to_keep <- intersect(all_climber_species, as.character(sb_tree$tip.label))
pruned_sb_tree <- keep.tip(sb_tree, tips_to_keep)
pruned_list <- subset(list_of_climber_distribution, names(list_of_climber_distribution) %in% pruned_sb_tree$tip.label)
template.map <- full_map
template.map[!is.na(template.map[])] <- 0
pd_climbers <- PDranges(pruned_list, pruned_sb_tree, cut=NULL, include.root=TRUE, template.map=template.map)
tmp.raster.list <- list()
for (i in 1:length(pruned_list)) {
r1 <- pruned_list[[i]]
r1 <- raster::resample(r1, template.map)
r1[is.na(r1)] <- 0
tmp.raster.list[[i]] <- raster::mask(r1, template.map)
print(i)
}
pruned_sp_rich <- raster::calc(raster::stack(tmp.raster.list), sum)
pruned_sp_rich <- raster::crop(pruned_sp_rich, raster::extent(full_map))
plot(pruned_sp_rich)
saveRDS(pd_climbers, file="1_descriptive/pd_climbers.Rdata")
saveRDS(pruned_sp_rich, file="1_descriptive/pruned_sp_rich.Rdata")
residuals <- plot.res(pd_climbers, pruned_sp_rich, dir=getwd(), pal.name = "RdBu", output = "residuals_pd")
residuals
# Plot residuals in better resolution
template.map <- readRDS("Data/template.map.Rdata")
template.map[!is.na(template.map[])] <- 0
r1 <- raster::resample(residuals, template.map)
r1[is.na(r1)] <- 0
r1 <- raster::mask(r1, template.map)
pal <- hcl.colors(30, palette = "RdBu", alpha = 1)
tmp <- crop(r1, extent(all_climbers_map))
teste_pos <- teste_neg <- tmp
max.v <- max(tmp[!is.na(getValues(tmp))])
teste_pos[teste_pos < 0.001] <- NA
teste_neg[teste_neg > -0.001] <- NA
tmp <- do.call(merge, list(teste_pos, teste_neg))
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
data("wrld_simpl")
plot(wrld_simpl, add=T)
plot(pruned_sp_rich)
dd_map <- pruned_sp_rich
dd_map[!is.na(dd_map[])] <- 0
dd_map <- pruned_sp_rich
dd_map[which(full_map[] < 25)] <- 0
plot(dd_map)
dd_map <- pruned_sp_rich
dd_map[which(pruned_sp_rich[] < 25)] <- 0
plot(dd_map)
tmp
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
dev.off()
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
tmp[which(pruned_sp_rich[] < 25)] <- NA
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
tmp[which(pruned_sp_rich[] < 25)]
tmp
plot(residuals)
residuals[which(pruned_sp_rich[] < 25)] <- NA
plot(residuals)
# Plot residuals in better resolution
template.map <- readRDS("Data/template.map.Rdata")
template.map[!is.na(template.map[])] <- 0
r1 <- raster::resample(residuals, template.map)
r1[is.na(r1)] <- 0
r1 <- raster::mask(r1, template.map)
pal <- hcl.colors(30, palette = "RdBu", alpha = 1)
tmp <- crop(r1, extent(all_climbers_map))
teste_pos <- teste_neg <- tmp
max.v <- max(tmp[!is.na(getValues(tmp))])
teste_pos[teste_pos < 0.001] <- NA
teste_neg[teste_neg > -0.001] <- NA
tmp <- do.call(merge, list(teste_pos, teste_neg))
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
data("wrld_simpl")
plot(wrld_simpl, add=T)
max.v
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,-3000))
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,-3000))
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
data("wrld_simpl")
plot(wrld_simpl, add=T)
# Plot all climbers map in better resolution
template.map <- readRDS("Data/template.map.Rdata")
template.map[!is.na(template.map[])] <- 0
r0 <- raster::resample(pd_climbers, template.map)
r0[is.na(r0)] <- 0
r0 <- raster::mask(r0, template.map)
pal <- hcl.colors(30, palette = "Inferno", alpha = 1)
tmp0 <- crop(r0, extent(pd_climbers))
plot(crop(template.map, extent(tmp0)), col="white", legend=FALSE)
plot(tmp0, col=rev(pal), add=T)
data("wrld_simpl")
plot(wrld_simpl, add=T)
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
data("wrld_simpl")
plot(wrld_simpl, add=T)
residuals <- plot.res(pd_climbers, pruned_sp_rich, dir=getwd(), pal.name = "RdBu", output = "residuals_pd")
residuals[which(pruned_sp_rich[] < 25)] <- NA
# Plot residuals in better resolution
template.map <- readRDS("Data/template.map.Rdata")
template.map[!is.na(template.map[])] <- 0
r1 <- raster::resample(residuals, template.map)
r1[is.na(r1)] <- 0
r1 <- raster::mask(r1, template.map)
pal <- hcl.colors(30, palette = "RdBu", alpha = 1)
tmp <- crop(r1, extent(all_climbers_map))
teste_pos <- teste_neg <- tmp
max.v <- max(tmp[!is.na(getValues(tmp))])
teste_pos[teste_pos < 0.001] <- NA
teste_neg[teste_neg > -0.001] <- NA
tmp <- do.call(merge, list(teste_pos, teste_neg))
plot(crop(template.map, extent(tmp)), col="white", legend=FALSE)
plot(tmp, col=rev(pal[c(1:13,17:30)]), add=T, zlim=c(max.v*-1,max.v))
data("wrld_simpl")
plot(wrld_simpl, add=T)
test
#-------
dd_map <- full_map
dd_map[!is.na(dd_map[])] <- 0
dd_map[which(full_map[] < 25)] <- 1
template.map <- readRDS("Data/template.map.Rdata")
template.map[!is.na(template.map[])] <- 0
r0 <- raster::resample(dd_map, template.map)
r0[is.na(r0)] <- 0
r0 <- raster::mask(r0, template.map)
pal <- hcl.colors(30, palette = "Inferno", alpha = 1)
tmp0 <- crop(r0, extent(dd_map))
plot(crop(template.map, extent(tmp0)), col="white", legend=FALSE)
plot(tmp0, col=rev(pal), add=T)
data("wrld_simpl")
plot(wrld_simpl, add=T)
test <- rasterToPolygons(tmp0, dissolve=T)
test
plot(test, col="green")
plot(test, col=c("blue","green"))
spplot(test, col=c("blue","green"))
plot(test, col=c("blue","green"), width=0.1)
plot(test, col=c("blue","green"), cex=0.1)
plot(test, col=c("blue","green"), lwd=0.1)
